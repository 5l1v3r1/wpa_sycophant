src/eap_peer/eap.c:	if (config->identity) {
src/eap_peer/eap.c:		for (i = 0; i < config->identity_len; i++) {
src/eap_peer/eap.c:			if (config->identity[i] == '@')
src/eap_peer/eap.c:		if (i < config->identity_len) {
src/eap_peer/eap.c:			realm_len = config->identity_len - i - 1;
src/eap_peer/eap.c:			os_memcpy(realm, &config->identity[i + 1], realm_len);
src/eap_peer/eap.c:	if (config->anonymous_identity) {
src/eap_peer/eap.c:		for (i = 0; i < config->anonymous_identity_len; i++) {
src/eap_peer/eap.c:			if (config->anonymous_identity[i] == '@')
src/eap_peer/eap.c:		if (i < config->anonymous_identity_len) {
src/eap_peer/eap.c:			realm_len = config->anonymous_identity_len - i - 1;
src/eap_peer/eap.c:			os_memcpy(realm, &config->anonymous_identity[i + 1],
src/eap_peer/eap.c:	if (!config->identity && !config->anonymous_identity &&
src/eap_peer/eap.c:	} else if (!encrypted && config->anonymous_identity) {
src/eap_peer/eap.c:		identity = config->anonymous_identity;
src/eap_peer/eap.c:		identity_len = config->anonymous_identity_len;
src/eap_peer/eap.c:		identity = config->identity;
src/eap_peer/eap.c:		identity_len = config->identity_len;
src/eap_peer/eap.c:			identity = config->identity;
src/eap_peer/eap.c:			identity_len = config->identity_len;
src/eap_peer/eap.c:		config->pending_req_identity++;
src/eap_peer/eap.c:	if (config->pending_req_identity)
src/eap_peer/eap.c:	*len = config->identity_len;
src/eap_peer/eap.c:	return config->identity;
src/eap_peer/eap_aka.c:	if (config && config->anonymous_identity && data->use_pseudonym) {
src/eap_peer/eap_aka.c:		data->pseudonym = os_malloc(config->anonymous_identity_len);
src/eap_peer/eap_aka.c:			os_memcpy(data->pseudonym, config->anonymous_identity,
src/eap_peer/eap_aka.c:				  config->anonymous_identity_len);
src/eap_peer/eap_aka.c:			data->pseudonym_len = config->anonymous_identity_len;
src/eap_peer/eap_aka.c:		if (config && config->imsi_identity) {
src/eap_peer/eap_aka.c:			identity = config->imsi_identity;
src/eap_peer/eap_aka.c:			identity_len = config->imsi_identity_len;
src/eap_peer/eap_fast.c:	    (config->pending_req_identity || config->pending_req_password ||
src/eap_peer/eap_peap.c:	    (config->pending_req_identity || config->pending_req_password ||
src/eap_peer/eap_sim.c:	if (config && config->anonymous_identity && data->use_pseudonym) {
src/eap_peer/eap_sim.c:		data->pseudonym = os_malloc(config->anonymous_identity_len);
src/eap_peer/eap_sim.c:			os_memcpy(data->pseudonym, config->anonymous_identity,
src/eap_peer/eap_sim.c:				  config->anonymous_identity_len);
src/eap_peer/eap_sim.c:			data->pseudonym_len = config->anonymous_identity_len;
src/eap_peer/eap_sim.c:		if (config && config->imsi_identity) {
src/eap_peer/eap_sim.c:			identity = config->imsi_identity;
src/eap_peer/eap_sim.c:			identity_len = config->imsi_identity_len;
src/eap_peer/eap_ttls.c:	    (config->pending_req_identity || config->pending_req_password ||
src/eap_peer/eap_ttls.c:	} else if (config->pending_req_identity ||
src/eap_peer/eap_ttls.c:		    (config->pending_req_identity ||
